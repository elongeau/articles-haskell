== le REPL

A présent je vais vous présenter `GHCi`, il deviendra vite votre meilleur ami.
D'abord, qu'est ce que `GHCi` ?
Il s'agit d'un REPLfootnote:[**R**ead **E**val **P**rint **L**oop] :
pour simplifier vous tapez du code et il l'évalue.

[NOTE]
.Pour briller en société
====
*GHCi* signifie __GHC interative environnement__, soit un environnement interactif pour le compilateur *GHC*.
*GHC* étant l'acronyme pour **G**lasgow **H**askell **C**ompiler.
====

Commençons, depuis votre shell : `ghci`

[source, haskell, linenums]
----
$ ghci
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help -- <1>
Prelude> "Hello world" -- <2>
"Hello world"
Prelude> 1 + 2 --<3>
3
Prelude> add x y = x + y -- <4>
Prelude> add 1 2
3
Prelude> :q -- <5>
Leaving GHCi.
----

<1> GHCi nous indique gentiment quelle version on utilise et comment avoir de l'aide `:h`.
<2> on peut saisir du texte
<3> ou des opérations mathématiques
<4> voici notre première fonction, voyez comme c'est concis
<5> Tapez `:q` pour sortir de GHCi (comme dans vim en fait)

=== Charger un fichier

Une fonctionnalité intéressante de GHCi est sa capacité de charger un fichier Haskell.
En ayant ce fichier :

[source, haskell,linenums]
----
include::mult.hs[]
----

Dans le GHCi (en étant dans le même répertoire) :

[source, haskell,linenums]
----
Prelude> :load mult.hs -- <1>
[1 of 1] Compiling Main             ( mult.hs, interpreted )
Ok, modules loaded: Main. -- <2>
*Main> mult 2 3 -- <3>
6
*Main>
----

<1> on utilise `:load` (ou `:l`) pour charger le fichier _mult.hs_
<2> GHCi compile le fichier, tout va bien
<3> on peut utiliser la fonction `mult`

Grâce à ceci on peut facilement travailler avec le contenu d'un fichier depuis GHCi
_mais les tests unitaires c'est bien aussi_.

=== Connaitre le type d'une expression

Utiliser `:t` suivi du nom d'une expression nous indique sa signature:

[source, haskell,linenums]
----
Prelude> :t add
add :: Num a => a -> a -> a
----

Je vais volontairement simplifier,
ici considerez `Num` comme une interface Java,
qui propose les opérations de base de mathématiques (addition, soustraction...).
Le type de la fonction nous dit qu'elle accepte comme paramètre tout type `a` implementant `Num`.

[NOTE]
.Notation des paramètres et type paramétré
====
Vous vous sentez surement perdu entre `a` et `x`,
c'est une norme de nommage :

* dans la signature d'une fonction,
un mot commenant par une minuscule est un *type paramétré*,
sinon c'est un *type concret*, comme `Int`.
* ailleurs c'est un *paramètre*
====
