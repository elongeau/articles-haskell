== ça ``fonction``ne ?

* [ ] gif "qu'est ce que vous voulez ? des fonctions"

On va écrire notre première fonction dans le GHCi :

[source, haskell,linenums]
----
Prelude> add x y = x + y -- <1>
Prelude> add 1 2 -- <2>
3 <3>
----

<1> on crée une fonction avec 2 paramètres `x` et `y`
<2> on appelle la fonction
<3> le résultat s'affiche

Vous remarquerez qu'a aucun moment on a précisé de type,
pourtant Haskell est capable de déterminer le type attendu par notre fonction,
il s'agit de l'**inférence de type**.

=== A propos de la signature d'une fonction

On va regarder de plus près au type de notre fonction `add`, pour rappel voici ce que nous donnais GHCi:

[source, haskell,linenums]
----
Prelude> :t add
add :: Num a => a -> a -> a
----

Le dernier `a` est le type de retour, les 2 premiers étant les 2 paramètres de la fonction.

Ce qui parait bizarre au premier abord est que le séparateur de paramètre `->` est le même que celui indiquant le type de retour `->`.
En fait il n'y pas de séparateur de paramètre, `->` indique seulement le retour d'une fonction.
Ça peut sembler compliqué mais si on réécrit la méthode `add` comme ceci:

[source,haskell,linenums]
----
add :: Num a => a -> (a -> a)
----

Maintenant on voit bien qu'``add`` est une fonction prenant un `Num` et retournant une nouvelle fonction de `Num -> Num`.

Ceci s'explique par le fait qu'en Haskell toutes les fonctions n'ont qu'un qu'un seul paramètre,
il s'agit toujours d'une fonction prenant un paramètre qui retourne une fonction, 
qui retourne une fonction,... qui retourne quelque chose.

Par exemple :
[source, haskell,linenums]
----
Prelude> add2 = add 2 -- <1>
Prelude> :t add2
add2 :: Num a => a -> a -- <2>
Prelude> add2 3 -- <3>
5
----

<1> on définit `add2` qui rajoutera 2 à son paramètre, on dit qu'``add`` est *partiellement appliqué*
<2> le type de `add2` est `Num -> Num`, soit le retour de `add`
<3> on utilise `add2` comme n'importe quelle fonction

Ce concept s'appelle le *currying*.

== Moooore functions

Le coeur d'Haskell c'est les fonctions, on peut donc

. retourner une fonction depuis une autre
. prendre une fonction en paramètre
. les composer

=== Retourner une fonction

Il s'agit tout simplement d'appliquer partiellement la fonction :

[source, haskell,linenums]
----
include::prefix.hs[]
----

[source, haskell,linenums]
----
*Main> res = prefix "Res = "
*Main> :t res
res :: Int -> String
*Main> res 2
"Res = 2"
----

Au lieu de donner à `prefix` tous les paramètres on ne lui donne que le premier,
`res` est alors une fonction de `Int -> String`.

=== Prendre une fonction en paramètre

[source, haskell,linenums]
----
include::prefix-in.hs[]
----

Pour indiquer que l'on attend une fonction on l'entoure de parenthèses `(Int -> String)`,
la fonction est alors assignée à la variable `f`.

[source, haskell,linenums]
----
Main> prefix (\i -> "Res = " ++ show i) 2
"Res = 2"
----

NOTE: On utilise ici la syntaxe pour une _lambda_, une fonction anonyme.

=== Composition de fonctions

Une des dernières choses que nous verrons sur les fonctions est leur composition,
il s'agit de chainer 2 fonctions (au moins 2). 

Prenons l'exemple d'un distributeur de café:

* `buy :: Coins -> Coffee` : fourni un café en échange de monnaie
* `developper :: Coffee -> Code` : donner du café à un développeur pour produire du code

Les composer reviendrait à obtenir une fonction ``Coins -> Code``.
Pour commencer, on va chainer nos fonctions de la manière la plus évidente qui soit : 

[source, haskell,linenums]
----
dev :: Coins -> Code
dev coins = developper (buy coins)
----

Mais je ne vous aurais pas parlé de composition si Haskell ne proposait pas un moyen plus pratique : 

[source, haskell,linenums]
----
dev2 :: Coins -> Code
dev2 coins = (developper . buy) coins
----

Il s'agit de `.` (lisez _compose_), c'est également une fonction (oui encore une): 

[source, haskell,linenums]
----
Main> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
----

Regardons ça de plus près, la signature de `.` nous indique qu'elle attend 2 fonctions `b -> c` et `a -> b` ainsi qu'un paramètre `a` pour donner un résultat de type `c`. 

Donc la première fonction est `g` et la seconde `f` puis on donne le paramètre a utilisé.
Mais on peut également voir le type de retour comme étant `a -> c`,
on a alors `.` comme étant une fonction prenant 2 fonctions et retournant la composition de celles-ci CQFD.

[source, haskell,linenums]
.`(.)` retourne une fonction
----
(.) :: (b -> c) -> (a -> b) -> (a -> c)
----

Il y a un élément contre-intuitif ici, l'ordre des fonctions passés à `.`. 
On passe en premier argument la fonction qui consomme le résultat de la fonction passé en second argument,
mais si on y réfléchit bien on suit plutot l'ordre _naturel_ pour composer les fonctions,
si on met les 2 styles cote à cote:

[source, haskell,linenums]
----
dev  coins =  developper ( buy  coins)
dev2 coins = (developper . buy) coins
----

On voit tout de suite que les fonctions sont appliqués dans le même ordre.
On dit que `.` est _associatif par la droite_.

Voici un exemple un peu plus réaliste de composition:

[source, haskell,linenums]
----
Prelude> ((\s -> s ++ "salue") . (\s -> s ++ " vous ") . reverse) "lleksaH"
"Haskell vous salue"
----

Décomposons tout ça, on commence par la droite:

* `lleksah` est le paramètre de la fonction `(\s -> s ++ "salue") . (\s -> s ++ " vous ") . reverse`
* `reverse` comme son nom l'indique inverse une `String`
* `\s -> s ++ " vous "` ajoute la chaine `` vous `` au résultat précédent
* `\s -> s ++ "salue"` fait de même avec `salue`

[options="header"]
|===
|Fonction| Résultat
|`reverse "lleksaH"`| "Haskell"
|`\s -> s ++ " vous "`| "Haskell vous "
| `\s -> s ++ "salue"`| "Haskell vous salue"
|===

Bon, on vient de voir les manipulations de base que l'ont peut faire avec des fonctions.
Maintenant on va regarder à ce qui se passe dedans.

* [ ] parler notation infix/postfix

