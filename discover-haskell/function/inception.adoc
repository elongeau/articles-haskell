Après avoir parler de comment gérer nos paramètres, regardons de plus près le corps de nos fonctions.
Pour l'instant on s'est contenté de fonction simple mais comment gérer un algorithme un peu plus complexe ?
Haskell nous fournis deux moyens pour cela : l'expression `let` et la clause `where`.

[NOTE]
.instruction vs expression
====
Avant d'entrer dans le vif du sujet, voici une petite digression sur ce que sont une instruction et une expression:

* une instruction _instruit_ le compilateur de réaliser une opération,
dans le cas d'un `if` l'une ou l'autre
* une expression est quelque chose qui doit être évalué,
comme `1 + 1`
====
=== `let` it be

L'expression `let` permet de définir un ensemble de valeur que l'on pourra utiliser dans le résultat final

[source,haskell,linenums]
----
include::let1.hs[]
----

<1> on définit la valeur intermédiaire `a`
<2> on peut également définir des fonctions
<3> le `in` permet de renvoyer le résultat final de l'expression, soit `f a`

NOTE: les valeurs définies dans l'expression `let` ne sont utilisables que dans celle-ci

=== Où est il ?

Le but de clause `where` est tout comme `let` de pouvoir définir des valeurs ou fonctions réutilisable.

[source,haskell,linenums]
----
include::where1.hs[]
----

La portée du `where` est le scope du matching le contenant

[source,haskell,linenums]
----
include::where.hs[]
----

Le but de ces 2 blocs est de découper nos fonctions en plus petit éléments tout en évitant de polluer le code avec des éléments utilisés qu'à un seul endroit.
Il est d'ailleurs possible d'imbriqués ces clauses (mais vous cherchez les ennuis).
