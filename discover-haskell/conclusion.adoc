== Conclusion

Nous voici à la fin de ce tour d'Haskell, nous avons appris les structures de base que l'on s'attend à trouver dans tout language.
Nous avons également souligné l'approche résolument fonctionnelle d'Haskell, on retrouve en effet ces dernières partout.
Bien évidemment il reste encore de nombreux concepts à aborder : composition de fonction, les __typeclasse__s et bien d'autres (je ne parle pas volontairement du mot en _M_).
Ce tutoriel n'ayant pas pour but de vous présenter tout Haskell mais de vous le faire découvrir.

En tant que javaiste de longue date,
ce qui m'a perturber au premier abord c'est la gestion des `IO`,
avoir une contrainte aussi forte n'est pas dans mes habitudes,
_fini les `println` en plein milieu_.
Mais dés qu'on considère que c'est simplement le principe de *séparation des besoins* appliqué au _type system_ les choses sont plus clair.

Mais, à mon avis, c'est l'aspect fonctionnel qui sera le vrai challenge pour tout développeur objet. Il faut vraiment penser en terme de fonction pour pouvoir être à l'aise et efficace. C'est ce changement de paradigme qui à la fois intéressant et challengeant.

Dans la vie de tous les jours, même si on ne fait pas d'Haskell, on peut toujours en profiter dans son bon vieux Java, rechercher la pureté des fonctions est toujours une bonne chose (et faicilite les tests) tout comme séparer les IOs du reste de votre code ou l'immuabilité.

Pour allez plus loin je vous laisse un _peu_ de lecture :

* le http://learnyouahaskell.com/[Learn You A Haskell For a Great Good] qui existe également en http://lyah.haskell.fr/[français]
* une référence de livre sur le https://wiki.haskell.org/Learning_Haskell#Online_tutorials[wiki]
* l'https://www.schoolofhaskell.com/[école d'Haskell]
