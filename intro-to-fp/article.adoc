= Introduction à la programmation fonctionnelle (avec Haskell)
:source-highlighter: pygments
:pygments-style: monokai
:icons: font
:source-language: haskell

.idée
====
* la fonction est un mapping entre un ensemble de valeur
* opposé pureté et effet (un programme pure ne fait que chauffer le processeur)
* functor et monade ?
* tout est valeur :
** montré un exemple entre la déclaration d'une valeur et d'une fonction
** la fonction est une valeur comme une autre
* polymorphisme
** dans `a -> b`, `a` peut être une fonction
** jeu pour déterminer ce que fait une fonction à partir de sa signature
* currying
====

Depuis quelques années maintenant la programmation fonctionnelle à le vent en poupe,
si comme moi vous êtes un javaiste vous avez vu l'arrivée des lambdas.
Mais la programmation fonctionnelle ne se résume pas à des lambdas (et Java reste fondamentalement un language orienté objet).
Donc partons à la découverte de la programmation fonctionnelle avec un language qui s'en revendique pleinement : https://www.haskell.org/[Haskell]

== Bon, déjà c'est quoi la __"programmation fonctionnelle"__ ?

Si on va au plus simple, il s'agit de considérer une fonction comme n'importe quelle autre valeur.

[source,haskell]
----
include::../samples/fun-as-value.hs[]
----

Comme on le voit la déclaration d'une _variable_ et d'une fonction sont identique, Haskell ne fait pas la distinction.
On dit des fonctions qu'elles sont des __citoyennes de première classe__, mais en l'occurrence elles sont au même niveau que n'importe quelle valeur.

Du coup on peut manipuler les fonctions comme le reste:

* les passer en paramètres de fonction
* les retourner depuis d'autre fonction
* les composer 
* les placer dans des collections
== A l'origine il y avait la fonction

====
c'est trop long
====

Avant de commencer nos pérégrinations, il faut préciser ce qu'est une fonction.
Dans le contexte de la programmation fonctionnelle il s'agit d'une opération qui transforme une valeur en une autre et cela sans effet de bord.
Penchons-nous de plus prêt sur ces 2 concepts.

Prenons par exemple la fonction `length` qui retourne la taille d'une chaine de caractère:

[source]
----
Prelude> length "hello" -- <1>
5
----

TIP: pas besoin de parenthèse pour appeler une fonction, on passe les arguments avec des espaces entre chaque paramètre.

On peut également voir cette fonction comme une `Map` ayant comme clé une chaine de caratère et comme valeur la taille de la chaine,
mais comme vous l'imaginez, écrire une fonction comme ceci prendrait un peu de temps donc on fait un calcul plutôt qu'un mapping.

Pour que ce concept de fonction comme un mapping de valeurs tienne il faut que la fonction soit *pure*.
Une fonction pure c'est une fonction:

* qui ne dépend pas d'un contexte externe (variable globale, élément aléatoire...).
* qui ne produit pas d'effet (logger, écrire dans un fichier...).
* qui ne s'appuie que sur les arguments qu'on lui passe pour produire un résultat.

Ainsi le résultat d'une fonction pure sera toujours le même pourvu qu'on lui donne les mêmes arguments.

A présent regardons de plus prêt cette notion d'effet, une fonction *pure* ne produit pas d'effet (hormis faire chauffer les processeurs),
or c'est ce que nous recherchons, nous voulons que le programme interragisse avec le monde pas qu'il vive dans sa bulle sans pouvoir en faire quoi que ce soit.

Définissons dans un premier temps ce qu'est un effet: c'est une interraction avec le monde externe (au programme) :

* soit en lecture: input de l'utilisateur, fichier, base de donnée...
* soit en écriture : rendre une page web, logger...

Avec Haskell, un effet se traduit avec le type `IO`,
chaque fois que l'on voudra lire ou modifier quelque chose en dehors du programme on devra wrapper la valeur dans une `IO`.

Trève de bavardage, regardons ça au travers d'un exemple:

[source]
----
include::../samples/io.hs[]
----

<1> `main` est le point de départ de notre programme,
cette fonction à le type `IO ()` soit une `IO` qui ne contient pas de valeur mais produit juste un effet.
<2> `getLine` à pour type `IO String`, c'est un effet avec une valeur (ici une `String`), valeur que l'on va attacher à `name`.
<3> ici pas d'effet, sans rentrer dans le détail de la syntaxe, `let` va nous permettre d'appeler nos fonctions pures
<4> on affiche le résultat du programme à la console.

Ce simple programme représente la substantifique moëlle d'un programme _fonctionnel_:

. on lit quelque chose du monde extérieure
. on manipule ces données avec des fonctions pure
. on produit un effet sur le monde

D'une certaine manière, programmer ainsi est assez similaire à l'http://alistair.cockburn.us/Hexagonal+architecture[architecture hexagonale].
L'hexagone, c'est les fonctions pures, et les effets tout ce qui en dehors de l'hexagone.

== Pureté et Effet


[NOTE]
On reviendra plus tard sur les fonctions à plusieurs arguments.



== Composition

== Manipuler des fonctions comme des _variables_

[source,haskell]
.une liste de fonction
----
include::../samples/fun-in-list.hs[]
----
 
`fs` est une liste de fonction, elle contient la fonction `reverse` qui... renverse une `String`,
et une lambda (__wouhou !!__) qui préfixe une `String` par `"Hello "`.

On va s'attarder un peu plus longtemps sur `run`.
`map` prend une liste et applique chaque élément de celle-ci grâce à la fonction en premier argument.
Dans notre cas c'est `\f -> f "world"`, comme c'est une liste de fonction `f` en est une, elle est alors appliqué sur `"world"`.

[source,haskell]
.à l'éxécution
----
*Main Data.Text> run
[ "dlrow"
, "Hello world"
]
----
