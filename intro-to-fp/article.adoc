= Introduction à la programmation fonctionnelle (avec Haskell)
:source-highlighter: pygments
:pygments-style: monokai
:icons: font
:source-language: haskell

.idée
====
* introduire le REPL (rapidement)
* https://functional.works-hub.com/blog/Functional-Programming-Jargon[FP Jargon]
* la fonction est un mapping entre un ensemble de valeur
* opposé pureté et effet (un programme pure ne fait que chauffer le processeur)
** en faire une petite bd, "chéri, tu peux monter le chauffage, OK je rajoute des fonctions pure"
* functor et monade ?
* tout est valeur :
** montré un exemple entre la déclaration d'une valeur et d'une fonction
** la fonction est une valeur comme une autre
* polymorphisme
** dans `a -> b`, `a` peut être une fonction
** jeu pour déterminer ce que fait une fonction à partir de sa signature
====

Depuis quelques années maintenant la programmation fonctionnelle à le vent en poupe,
si comme moi vous êtes un javaiste vous avez vu l'arrivée des lambdas.
Mais la programmation fonctionnelle ne se résume pas à des lambdas (et Java reste fondamentalement un language orienté objet).
Donc partons à la découverte de la programmation fonctionnelle avec un language qui s'en revendique pleinement : https://www.haskell.org/[Haskell]

== Bon, déjà c'est quoi la __"programmation fonctionnelle"__ ?

Si on va au plus simple, il s'agit de considérer une fonction comme n'importe quelle autre valeur.

[source,haskell]
----
include::../samples/fun-as-value.hs[]
----

Comme on le voit la déclaration d'une _variable_ et d'une fonction sont identique, Haskell ne fait pas la distinction.
On dit des fonctions qu'elles sont des __citoyennes de première classe__, mais en l'occurrence elles sont au même niveau que n'importe quelle valeur.

Du coup on peut manipuler les fonctions comme le reste:

* les passer en paramètres de fonction
* les retourner depuis d'autre fonction
* les composer 
* les placer dans des collections

== Fonction de haut niveau

On désigne par cette terminologie les fonctions qui prennent en argument et/ou retournent une fonction.
par exemple:

[source,haskell]
----
include::../samples/fun-as-arg.hs[]
----

[NOTE]
.Un peu de syntaxe
====
* `Show b` : pour dire que la valeur de type `b` sera convertible en `String`
* `(a -> b)` : une fonction polymorphique de `a` vers `b` (en java, on parle de _generique_, on écrirait `<A>`), on l'entoure de parenthèse pour indiquer qu'il s'agit d'une fonction et non pas de deux paramètres distincts
* `IO ()` : là c'est un peu plus complexe mais il s'agit du moyen par lequel Haskell produit un effet, ici écrire sur la console (on y reviendra, promis)
* `repeatMe f value count` : la syntaxe haskell impose de rappeller le nom de la fonction suivi de ces arguments nommés
* le `return` n'est pas un mot clé mais une fonction, ici il permet de dire : _ne fais rien_
====

<1> La fonction passé en argument est `f`, on lui passe le second argument, la valeur de type `a` et on affiche le résultat
<2> on rappelle `repeatMe` avec les mêmes arguments sauf le compteur décrémenté
<3> si on a fini de répeter on s'arrête

[source,haskell]
.à l'éxécution
----
λ ❯ repeatMe (\x -> show (2*x)) 1 5
"2"
"2"
"2"
"2"
"2"
----
Maintenant regardons comment retourner une fonction:

[source,haskell]
----
include::../samples/return-fun.hs[]
----

On retourne la lambda (une fonction anonyme) `\s -> s ++ (show sum)`

[source,haskell]
.à l'éxécution
----
λ ❯ f = logAdd 1 2
λ ❯ f "1 + 2 = "
----

On applique `"1 + 2 = "` à la fonction retourner par `logAdd 1 2`

On peut également se passer de la valeur temporaire `f` et écrire

[source,haskell]
----
λ ❯ logAdd 1 2 "1 + 2 = "
"1 + 2 = 3"
----

> Etrange, ça ressemble à appliquer des paramètres à une fonction normale

Tout à fait, retourner une fonction revient à avoir une fonction à laquelle on ne donne pas tous ces paramètres. 
Dans ce cas la valeur retournée est une fonction attendant le reste des paramètres, on peut donc réécrire notre fonction comme ceci:

[source,haskell]
----
include::../samples/return-fun-2.hs[]
----

[source,haskell]
----
λ ❯ f = logAdd 1 2
λ ❯ :t f
f :: String -> String
λ ❯ f "1 + 2 = "
"1 + 2 = 3"
-- mais on aurait aussi pu faire
λ ❯ g = logAdd 1
λ ❯ :t g
g :: Int -> String -> String
λ ❯ g 2 "1 + 2 = "
"1 + 2 = 3"
----

[TIP]
Faire `:t` dans le REPL d'Haskell permet d'avoir le type d'une valeur

Le fait de séparer les paramètres d'une fonction s'appelle le **currying**,
l'idée est de considérer que toutes les fonctions n'ont qu'un seul paramètre et retourne une valeur:

* une fonction à 1 paramètre retourne une valeur
* une fonction à __2 paramètres__ est une fonction à 1 paramètre retournant une fonction à 1 paramètre
* ...
* une fonction à __N paramètres__ est une fonction à 1 paramètre retournant une fonction à 1 paramètre retournant une fonction... que retourne une valeur.

[NOTE]
Avec Haskell le **currying** est natif, il n'y a pas de notion de _groupe_ de paramètres,
mais pour la compréhension on parlera __des paramètres__ d'une fonction.


== Composition

Un des trucs fun de la programmation fonctionnelle c'est de composer des fonctions.
On prend 2 fonctions et on en fait qu'une seule

[source,haskell,linenums]
----
λ ❯ f s = reverse s
λ ❯ g s = "Hello " ++ s
λ ❯ h s = (g . f) s
λ ❯ h "dlrow"
"Hello world"
----

Ce nous intéresse ici c'est la fonction `.` (lisez _compose_), voici sa signature: `(b -> c) -> (a -> b) -> a -> c`.
On voit qu'elle prend 2 fonctions en paramètres et retourne une fonction `a -> c`,
quand celle ci est appliqué:

. elle passe son paramètre de type `a` à la fonction `a -> b` (le deuxième paramètre de `.`)
. puis son résultat de type `b` est fourni à la fonction `b -> c` qui produit le résultat final

l'ordre peut paraître contre intuitif, mais implémentons notre propre fonction `compose`:

[source,haskell]
----
include::../samples/compose.hs[]

-- à l'éxécution
λ ❯ f s = reverse s
λ ❯ g s = "Hello " ++ s
λ ❯ (compose g f) "dlrow"
"Hello world"
----

Comment fait on pour composer ? 
On applique nos fonctions dans une lambda :`\x -> g (f x)` et là on retrouve l'ordre de nos paramètres.
====
* point free programming
** `f` est une fonction attendant une _signature_, `truc muche` à pour type _un type_ donc c'est bon
** il faut voir `f` comme une valeur _simple_ (pas de paramètre) qui a pour type toute la signature de la fonction 
====
== Manipuler des fonctions comme des _variables_


[source,haskell]
.une liste de fonction
----
include::../samples/fun-in-list.hs[]
----
 
`fs` est une liste de fonction, elle contient la fonction `reverse` qui... renverse une `String`,
et une lambda qui préfixe une `String` par `"Hello "`.

On va s'attarder un peu plus longtemps sur `run`.
`map` prend 2 paramètres : une fonction et une liste.
Chaque élément de la liste est fourni comme paramètre à la fonction.
Dans notre cas la fonction est la lambda `\f -> f "world"`, les éléments de la liste sont des fonctions donc `f` en est une, on lui passe alors le paramètre `"world"`.

[source,haskell]
.à l'éxécution
----
*Main Data.Text> run
[ "dlrow"
, "Hello world"
]
----
