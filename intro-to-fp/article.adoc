= Introduction à la programmation fonctionnelle (avec Haskell)
:source-highlighter: pygments
:pygments-style: monokai
:icons: font
:source-language: haskell

.idée
====
* la fonction est un mapping entre un ensemble de valeur
* opposé pureté et effet (un programme pure ne fait que chauffer le processeur)
* functor et monade ?
* tout est valeur :
** montré un exemple entre la déclaration d'une valeur et d'une fonction
** la fonction est une valeur comme une autre
* polymorphisme
** dans `a -> b`, `a` peut être une fonction
** jeu pour déterminer ce que fait une fonction à partir de sa signature
* currying
** fonction partiellement appliquée
====

Depuis quelques années maintenant la programmation fonctionnelle à le vent en poupe,
si comme moi vous êtes un javaiste vous avez vu l'arrivée des lambdas.
Mais la programmation fonctionnelle ne se résume pas à des lambdas (et Java reste fondamentalement un language orienté objet).
Donc partons à la découverte de la programmation fonctionnelle avec un language qui s'en revendique pleinement : https://www.haskell.org/[Haskell]

== Bon, déjà c'est quoi la __"programmation fonctionnelle"__ ?

Si on va au plus simple, il s'agit de considérer une fonction comme n'importe quelle autre valeur.

[source,haskell]
----
include::../samples/fun-as-value.hs[]
----

Comme on le voit la déclaration d'une _variable_ et d'une fonction sont identique, Haskell ne fait pas la distinction.
On dit des fonctions qu'elles sont des __citoyennes de première classe__, mais en l'occurrence elles sont au même niveau que n'importe quelle valeur.

Du coup on peut manipuler les fonctions comme le reste:

* les passer en paramètres de fonction
* les retourner depuis d'autre fonction
* les composer 
* les placer dans des collections

== Fonction de haut niveau

====
regrouper ici les fonctions en paramètres et retourner une fonction.
exemple de passer une connection (warning pour les puristes haskell)
====

== Composition

== Manipuler des fonctions comme des _variables_

[source,haskell]
.une liste de fonction
----
include::../samples/fun-in-list.hs[]
----
 
`fs` est une liste de fonction, elle contient la fonction `reverse` qui... renverse une `String`,
et une lambda qui préfixe une `String` par `"Hello "`.

On va s'attarder un peu plus longtemps sur `run`.
`map` prend 2 paramèetres : une fonction et une liste.
Chaque élément de la liste est fourni comme paramètre à la fonction.
Dans notre cas la fonction est la lambda `\f -> f "world"`, les éléments de la liste sont des fonctions donc `f` en est une, on lui passe alors le paramètre `"world"`.

[source,haskell]
.à l'éxécution
----
*Main Data.Text> run
[ "dlrow"
, "Hello world"
]
----
