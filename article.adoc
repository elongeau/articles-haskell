= C'est quoi le fonctionnel dans programmation fonctionnelle ?
:source-highlighter: pygments
:pygments-style: manni
:icons: font
:source-language: haskell
:samplesdir: ./samples
:2c: ::

Depuis quelques années maintenant la programmation fonctionnelle à le vent en poupe,
si comme moi vous êtes un javaiste vous avez vu l'arrivée des lambdas.
Mais Java (entre autre) reste attaché au paradigme objet.
Donc partons à l'aventure au pays des fonctions et des lambdas.

== Dis papa c'est quoi une lambda ?

Une lambda c'est tout simplement une fonction anonyme, ça passera mieux avec un exemple:

[source,java]
----
include::{samplesdir}/Lambda.java[]
----

Ici on utilise l'API Stream de Java 8 pour doubler chaque nombre du `Stream`.
`map` applique successivement la lambda `x -> x * 2` à chaque élément du `Stream`.

Ce que nous apporte l'utilisation d'une lambda c'est la concision, la lecture du code nous informe tout de suite de ce que l'on veut faire : multiplier un nombre par 2.
Comment est appliqué la lambda dépendra de l'appelant (ici `map`).

=== Et les closures dans tout ça ?

Une closure ressemble à une lambda mais elle embarque en plus un *contexte*:

[source,java]
----
include::{samplesdir}/Closure.java[]
----

Avez vous devinez pourquoi `x -> x + i` est un closure ?
Elle n'a pas de nom comme une lambda mais d'où vient le `i` ?
De la méthode `add`, la variable `i` fait parti du contexte dont on parlait. 
Lorsque la fonction `x -> x + i` s'exécutera, le `i` viendra du contexte de la closure.

== Les fonctions en Haskell

On va maintenant partir sur des exemples en https://www.haskell.org/[Haskell].
Pourquoi me direz-vous ?
Et bien parce que Haskell est un langage strictement fonctionnel et sa syntaxe permet des petits _tour de passe-passe_ plus à même d'exposer mon propos.

Donc avant de commencer, une petite leçon d'Haskell :

On ne parle pas de variable en Haskell car tout est immutable, on utilisera plutôt le terme *valeur*.

Déclarer une valeur ou une fonction se fait comme ceci:

[source,haskell]
----
include::{samplesdir}/fun-as-value.hs[]
----

La première ligne de chaque bloc représente la signature sous la forme ``<nom> {2c} <type>``.
La suivante assigne une _expression_ à un _nom_ (`42` à `i` et `lenght s` à `f`). 
Remarquez comment la syntaxe Haskell ne distingue pas une valeur d'une fonction, ceci nous indique quelque chose.
Dans un langage fonctionnel, une fonction est une valeur, c'est le type de la valeur qui déterminera son usage et pas sa nature (_variable_ ou fonction).

Et pour utiliser tout ça
[source,haskell]
----
λ> i
42
λ> f "Hello"
5
----

[TIP]
J'utilise https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html[ghci], c'est un REPL pour Haskell.

Intéressons nous au fonction à _plusieurs_ paramètres:

[source,haskell]
----
include::{samplesdir}/multi-param.hs[]
----

On retrouve une syntaxe standard, le ``Int -> Int -> Int`` nous indique que la fonction nécessite deux paramètres de type `Int` pour renvoyer une valeur de type `Int` également.
Sur la deuxième ligne les paramètres sont séparer par des espaces et on retrouve ensuite le corps de la fonction.

Pour appliquer notre fonction :

[source,haskell]
----
λ> add 1 2 -- toujours des espaces pour séparer
3
----

Regardons maintenant comment écrire une lambda: `\x -> x * x`.
Le `\` indique que ce qui va suivre sera une lambda, on sépare les paramètres du corps de la fonction avec ``->``.
On l'applique ainsi:

[source,haskell]
----
λ> (\x -> x * x) 2 -- on doit entourer la lambda entre parenthèses sinon le compilateur va croire que `2` en fait parti
4
----

Pour faire une lambda à plusieurs paramètres, on fait comme ceci : ``\x -> \y -> x + y``.
On a une lambda qui contient une closure.
On vient ici de faire quelque chose très intéressant, un petit indice d'abord ``\x -> (\y -> x + y)``.
Toujours pas ?
Alors je viens d'isoler la closure `\y -> x + y` ceci nous indique deux choses: d'une part une fonction peut en retourner une autre, on parle alors de **higher order function**.
D'autre part les deux versions sont parfaitement identiques (les parenthèses sont facultatives).
On peut alors se dire qu'il s'agit :

* soit d'une fonction à *deux* paramètres retournant une valeur.
* soit d'une fonction à *un* paramètre retournant une fonction à *un* paramètre retournant une *valeur*.

Ce dernier concept s'appelle le **currying**, il consiste à considérer qu'une fonction n'aura toujours qu'un paramètre et un seul retour.
On simule une fonction à plusieurs paramètres en disant qu'elle retourne une nouvelle fonction à un paramètre et ainsi de suite jusqu'au résultat final.

La syntaxe Haskell permet nativement le currying :

[source,haskell]
----
include::{samplesdir}/concat.hs[]
-- dans le REPL:
λ ❯ f "Hello " "world" -- <1>
"Hello world"
λ ❯ prefixWithHello = f "Hello " -- <2>
λ ❯ :t prefixWithHello
prefixWithHello :: String -> String -- <3>
λ ❯ prefixWithHello "FP" -- <4>
"Hello FP"
λ ❯ prefixWithHello "currying"
"Hello currying"
----

<1> on l'utilise normalement
<2> on ne passe que le premier argument et on assigne la fonction restante
<3> la fonction restante est ``String -> String`` : c'est ce qu'on attendait (dans le REPL `:t` nous donne le type d'une valeur)
<4> on peut utiliser la nouvelle fonction comme n'importe quelle autre

[NOTE]
====
Lorsque l'on ne passe tous ces arguments à une fonction on dit qu'on l'**applique partiellement**
====

== Une fonction dans la fonction

Vous vous souvenez du premier exemple en Java ? 
On passait une lambda à la fonction `map`, il s'agit aussi d'une **higher order function** comme on passe une fonction comme paramètre d'une autre.

Un petit exemple en haskell bien entendu:

[source,haskell]
----
λ> map (\x -> x * 2) [1,2,3]
[ 2, 4, 6 ]
----

On entoure la lambda de parenthèses sinon le compilateur ne saura pas où elle s'arrête !
`[1,2,3]` est la liste d'entier.

Si vous voulez faire vos propres fonctions prenant une (ou des, soyons fous) fonction il faut feinter, regardons la signature de `map`:

[source,haskell]
----
λ> :t map
map :: (a -> b) -> [a] -> [b]
----

Il faut, une nouvelle fois, cerner la fonction avec des parenthèses.
`map` est donc une fonction prenant une fonction (de type `a -> b`) et une liste puis retourne une liste.

[NOTE]
====
Les `a` et `b` dans la signature ne sont pas des variables mais des types polymorphes, cela veut dire que l'on pourra les remplacer par n'importe quel type.
====

== Une fonction plus une fonction égale... une fonction

Dans tout projet de développement, on a tendance à rechercher à faire des composants (objet, procédure, fonction...) petit et composable.
Personnellement je vois ça comme des lego, des centaines de petites pièces qui ne peuvent rien seule, mais dés qu'on les assemble comme il faut on peut obtenir ce qu'on veut.

====
image de lego ?
====

Avec des fonctions on peut pousser la composition assez loin, trêve de bavardage, un exemple!

[source,haskell]
----
λ> greetings s = "Hello " ++ s
λ> reverseGreet s = (greetings . reverse) s
λ> reverseGreet "dlrow"
"Hello world"
----

Ce qui nous intéresse ici c'est la fonction `.` (lisez _compose_), voici sa signature: `(b -> c) -> (a -> b) -> a -> c`.
On voit qu'elle prend 2 fonctions en paramètres et retourne une fonction `a -> c`,
quand celle-ci est appliqué:

. elle passe son paramètre de type `a` à la fonction `a -> b` (le deuxième paramètre de `.`)
. la valeur produite, de type `b`, est alors fourni à la fonction `b -> c` qui produit le résultat final

L'ordre peut paraître contre intuitif, mais implémentons notre propre fonction `compose`:

[source,haskell]
----
include::{samplesdir}/compose.hs[]

-- à l'éxécution
λ> greetings s = "Hello " ++ s
λ> (compose greetings reverse) "dlrow"
"Hello world"
----

Dans notre exemple, comment fait on pour composer ? 
On applique nos fonctions dans une lambda: `\x -> g (f x)` et là on retrouve l'ordre de nos paramètres,
d'abord `f x` puis son résultat est passé à `g`.

== Libérez les paramètres

Pour construire la fonction `reverseGreet` qu'a t'on fait ?

[source,haskell]
----
reverseGreet :: String -> String
reverseGreet s = (greetings . reverse) s
----

On indique que l'on a un paramètre `s` auquel on applique la fonction (composée) ``(greetings . reverse)``.
Saviez-vous que l'on pouvait se passer du paramètre ?
En tout cas ne pas l'écrire ?

Je vais vous demander un peu de souplesse mentale: une fonction étant une valeur elle a un type, du moment qu'elle à une valeur du bon type tout ira bien, donc:

* Quel est le type de `reverseGreet` ? `String -> String`.
* Quel est le type de `greetings . reverse` ? `String -> String`.

A partir de là on peut simplement écrire

[source,haskell]
----
reverseGreet :: String -> String
reverseGreet = greetings . reverse
----

Plus besoin de paramètre

[NOTE]
====
Ce style de notation est dite **point free**, on n'écrit plus les paramètres on décrit le flux de transformation des données.
====

== Tout est fonction

====
reprendre l'exemple de la composition et enlever les paramètres.
``map (\x -> x * 2) [1,2,3]`` peut s'écrire ``map ((*) 2) [1,2,3]``
====

== conclusion

On a vu que dans un langage fonctionnel, une fonction est une valeur comme une autre que l'on peut aisément manipuler. 
La programmation fonctionnelle propose un nouveau challenge car on change de paradigme, 
au délà d'apprendre une nouvelle syntaxe il faut réussir à penser en terme de fonction: quand les injecter, les enchainer...

Je vous encourage vivement à apprendre la programmation fonctionnelle (avec Haskell en particulier, car vous serez contraint d'utiliser ce paradigme),
pour vous améliorez en tant que développeur.
Même si je continues à coder en Java au jour le jour, j'essaye de rendre mes fonctions le plus pure possible pour séparer aisément les calculs des effets.
